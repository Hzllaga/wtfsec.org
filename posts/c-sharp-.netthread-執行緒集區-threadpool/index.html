<!doctype html><html lang=zh-cn><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content=".NET"><meta name=description content="執行緒集區會維持一個最小閒置執行緒數目，當使用ThreadPool.QueueUserWorkItem方法時會喚醒正在休眠的執行緒，這樣一來就比我們不斷直接使用Thread類別重新建立執行緒還要來的節省資源一點，執行緒集區內的執行緒工作滿檔時，會再自動增加執行緒的數量。"><title>[C#.NET][Thread] 執行緒集區 – ThreadPool&nbsp;&ndash;&nbsp;WTFSec</title><link rel=stylesheet href=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/github-gist.min.css><link rel=stylesheet href=/css/core.min.58bc4672a8045a0810ba4ad30a08c6d5589db1109ca0aa2e07c5e5438201ea8d11642ffa31d8ee7665d6a1b66ab9a3c5.css integrity=sha384-WLxGcqgEWggQukrTCgjG1VidsRCcoKouB8XlQ4IB6o0RZC/6MdjudmXWobZquaPF><meta name=twitter:card content="summary"><meta name=twitter:title content="[C#.NET][Thread] 執行緒集區 – ThreadPool"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><span class="site name">WTFSec</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>分类</a><a class="nav item" href=/tags/>标签</a><a class="nav item" href=/link/>友链</a>
<input placeholder="Google 站内搜索" id=search_input style=width:150px>
<button onclick=search()><svg width="13" height="13" viewBox="0 0 13 13"><path d="m4.8495 7.8226c.82666.0 1.5262-.29146 2.0985-.87438.57232-.58292.86378-1.2877.87438-2.1144.010599-.82666-.28086-1.5262-.87438-2.0985-.59352-.57232-1.293-.86378-2.0985-.87438-.8055-.010599-1.5103.28086-2.1144.87438-.60414.59352-.8956 1.293-.87438 2.0985.021197.8055.31266 1.5103.87438 2.1144.56172.60414 1.2665.8956 2.1144.87438zm4.4695.2115 3.681 3.6819-1.259 1.284-3.6817-3.7.0019784-.69479-.090043-.098846c-.87973.76087-1.92 1.1413-3.1207 1.1413-1.3553.0-2.5025-.46363-3.4417-1.3909s-1.4088-2.0686-1.4088-3.4239.4696-2.4966 1.4088-3.4239c.9392-.92727 2.0864-1.3969 3.4417-1.4088 1.3553-.011889 2.4906.45771 3.406 1.4088.9154.95107 1.379 2.0924 1.3909 3.4239.0 1.2126-.38043 2.2588-1.1413 3.1385l.098834.090049z"/></svg></button></nav></div><script>function search(){const search_value=document.getElementById("search_input").value;if(search_value!==''){window.open("/search/?q="+search_value,"_blank");}}
document.getElementById("search_input").addEventListener("keydown",function(e){if(e.key==="Enter"){search()}});</script></span></div></section><section id=content><div class=article-container><section class="article header"><h1 class="article title">[C#.NET][Thread] 執行緒集區 – ThreadPool</h1><p class="article date"><span class=lang><a>Hzllaga</a> </span>Thursday, September 6, 2018</p></section><article class="article markdown-body"><p>看了安德魯的文章，可以讓人裡解ThreadPool背後在玩的把戲 ThreadPool <a href=https://columns.chicken-house.net/2007/12/14/threadpool-%E5%AF%A6%E4%BD%9C-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ target=_blank>實作 #1. 基本概念</a>，絕對會讓您收獲不少。</p><p>執行緒集區會維持一個最小閒置執行緒數目，當使用<a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.threadpool.queueuserworkitem?redirectedfrom=MSDN&view=netframework-4.8#overloads" target=_blank>ThreadPool.QueueUserWorkItem</a>方法時會喚醒正在休眠的執行緒，這樣一來就比我們不斷直接使用Thread類別重新建立執行緒還要來的節省資源一點，執行緒集區內的執行緒工作滿檔時，會再自動增加執行緒的數量。</p><p>另外MSDN有提到，</p><p>如果應用程式受到突然增加的活動影響 (例如，大量佇列的執行緒集區工作)，請使用 <a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.threadpool.setminthreads?redirectedfrom=MSDN&view=netframework-4.8#System_Threading_ThreadPool_SetMinThreads_System_Int32_System_Int32_" target=_blank>SetMinThreads</a> 方法增加最小閒置執行緒的數目。否則，建立新閒置執行緒時的內建延遲可能會造成瓶頸。</p><p>這表示若有需要大量執行緒數量要增加時，反而會因為這些延遲而拖垮系統，保哥也是曾經受到它的荼毒 ，<a href=https://blog.miniasp.com/post/2009/04/10/The-thread-pool-worker-threads-per-available-processor target=_blank>使用 ThreadPool 時應注意預設同時執行的 Thread 數量</a> 。</p><p><a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.threadpool.queueuserworkitem?redirectedfrom=MSDN&view=netframework-4.8#overloads" target=_blank>ThreadPool.QueueUserWorkItem</a>方法需要傳入一個<a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.waitcallback?redirectedfrom=MSDN&view=netframework-4.8" target=_blank>WaitCallback委派</a>，這個委派的簽名是<div class=highlight><pre class=chroma><code class=language-csharp data-lang=csharp><span class=k>public</span> <span class=k>delegate</span> <span class=k>void</span> <span class=n>WaitCallback</span> <span class=p>(</span>
    <span class=n>Object</span> <span class=n>state</span>
<span class=p>)</span>
</code></pre></div>所以只要建立跟它有相同簽名的方法，就可以建立WaitCallback委派了。</p><p>ThreadPool.QueueUserWorkItem方法只有兩種多載，除了固定要傳WaitCallback委派，另一個參數就是object物件，所以表示我們可以傳很大的東西進去DoWorker(object number)方法裡<div class=highlight><pre class=chroma><code class=language-csharp data-lang=csharp><span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>(</span><span class=kt>string</span><span class=p>[</span><span class=p>]</span> <span class=n>args</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ThreadPool</span><span class=p>.</span><span class=n>QueueUserWorkItem</span><span class=p>(</span><span class=k>new</span> <span class=n>WaitCallback</span><span class=p>(</span><span class=n>DoWorker</span><span class=p>)</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span><span class=p>;</span>
    <span class=n>ThreadPool</span><span class=p>.</span><span class=n>QueueUserWorkItem</span><span class=p>(</span><span class=k>new</span> <span class=n>WaitCallback</span><span class=p>(</span><span class=n>DoWorker</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>static</span> <span class=k>void</span> <span class=n>DoWorker</span><span class=p>(</span><span class=kt>object</span> <span class=n>number</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>//TODO..
</span><span class=c1></span><span class=p>}</span>
</code></pre></div></p><h2 id=先來看看簡單的使用範例>先來看看簡單的使用範例</h2><h3 id=傳入一個參數>傳入一個參數</h3><p><div class=highlight><pre class=chroma><code class=language-csharp data-lang=csharp><span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>(</span><span class=kt>string</span><span class=p>[</span><span class=p>]</span> <span class=n>args</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1</span><span class=m>0</span><span class=p>;</span> <span class=n>i</span>  <span class=p>)</span>
    <span class=p>{</span>
        <span class=n>ThreadPool</span><span class=p>.</span><span class=n>QueueUserWorkItem</span><span class=p>(</span><span class=k>new</span> <span class=n>WaitCallback</span><span class=p>(</span><span class=n>DoWorker</span><span class=p>)</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Main thread exit&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=n>Console</span><span class=p>.</span><span class=n>ReadKey</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>static</span> <span class=k>void</span> <span class=n>DoWorker</span><span class=p>(</span><span class=kt>object</span> <span class=n>number</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>Thread</span> <span class=n>t</span> <span class=p>=</span> <span class=n>Thread</span><span class=p>.</span><span class=n>CurrentThread</span><span class=p>;</span>
    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;No.{0}-Thread[{1}]:{2}&#34;</span><span class=p>,</span> <span class=n>number</span><span class=p>,</span> <span class=n>t</span><span class=p>.</span><span class=n>ManagedThreadId</span><span class=p>,</span> <span class=n>t</span><span class=p>.</span><span class=n>ThreadState</span><span class=p>)</span><span class=p>;</span>
    <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>1</span><span class=m>0</span><span class=m>0</span><span class=m>0</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div>因為閒置的執行緒被喚醒，所以可以看到，有許多重複的執行緒會出現</p><p><img src=https://cdn.wtfsec.org/img/20200223172435.png alt></p><h3 id=傳入多個參數>傳入多個參數</h3><p>若需要傳入不只一個參數，我們可以利用類別(class)或結構(struct)來傳入，當然你也可以傳入集合…反正你想的到的資料型態什麼都能傳，只要再DoWorker方法裡記得轉型就可以了。<div class=highlight><pre class=chroma><code class=language-csharp data-lang=csharp><span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>(</span><span class=kt>string</span><span class=p>[</span><span class=p>]</span> <span class=n>args</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>Book</span> <span class=n>book</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Book</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=n>book</span><span class=p>.</span><span class=n>author</span> <span class=p>=</span> <span class=s>&#34;余小章&#34;</span><span class=p>;</span>
    <span class=n>book</span><span class=p>.</span><span class=n>price</span> <span class=p>=</span> <span class=m>1</span><span class=m>0</span><span class=m>0</span><span class=m>0</span><span class=p>;</span>
    <span class=n>book</span><span class=p>.</span><span class=n>title</span> <span class=p>=</span> <span class=s>&#34;MVP&#34;</span><span class=p>;</span>
    <span class=n>ThreadPool</span><span class=p>.</span><span class=n>QueueUserWorkItem</span><span class=p>(</span><span class=k>new</span> <span class=n>WaitCallback</span><span class=p>(</span><span class=n>DoWorker</span><span class=p>)</span><span class=p>,</span> <span class=n>book</span><span class=p>)</span><span class=p>;</span> 

    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Main thread exit&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=n>Console</span><span class=p>.</span><span class=n>ReadKey</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>static</span> <span class=k>void</span> <span class=n>DoWorker</span><span class=p>(</span><span class=kt>object</span> <span class=n>book</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>Thread</span> <span class=n>t</span> <span class=p>=</span> <span class=n>Thread</span><span class=p>.</span><span class=n>CurrentThread</span><span class=p>;</span>
    <span class=n>Book</span> <span class=n>b</span> <span class=p>=</span> <span class=p>(</span><span class=n>Book</span><span class=p>)</span><span class=n>book</span><span class=p>;</span>
    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Thread[{0}]:{1}&#34;</span><span class=p>,</span> <span class=n>t</span><span class=p>.</span><span class=n>ManagedThreadId</span><span class=p>,</span> <span class=n>t</span><span class=p>.</span><span class=n>ThreadState</span><span class=p>)</span><span class=p>;</span>
    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;author:{0},title{1},price:{2}&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>author</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>title</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>price</span><span class=p>)</span><span class=p>;</span> 

    <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>1</span><span class=m>0</span><span class=m>0</span><span class=m>0</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>public</span> <span class=k>struct</span> <span class=nc>Book</span>
<span class=p>{</span>
    <span class=k>public</span> <span class=kt>decimal</span> <span class=n>price</span><span class=p>;</span>
    <span class=k>public</span> <span class=kt>string</span> <span class=n>title</span><span class=p>;</span>
    <span class=k>public</span> <span class=kt>string</span> <span class=n>author</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><img src=https://cdn.wtfsec.org/img/20200223172541.png alt></p></article><section class="article labels"><a class=category href=/categories/%E8%BD%AC%E8%BD%BD/>转载</a><a class=tag href=/tags/%2enet/>.NET</a></section></div><div class="article bottom"><section class="article navigation"><p><a class=link href=/posts/ecshop%E5%85%A8%E7%B3%BB%E5%88%97%E7%89%88%E6%9C%AC%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/><span class=li>&larr;</span>ECShop全系列版本远程代码执行高危漏洞分析</a></p><p><a class=link href=/posts/ecshop_rce_scanner-%E4%B8%80%E6%AC%BE%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84ecshop%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/><span class=li>&rarr;</span>EcShop_RCE_Scanner – 一款轻量级的EcShop漏洞扫描工具</a></p></section></div></section><section id=footer><div class=footer-wrap><p class=copyright>©2014-2020 WTFSec.</p><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank>Hugo</a><span> and the </span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank>Notepadium</a></p><p class=powerby><span>CDN by </span><a href=https://cf.wtfsec.org target=_blank>Cloudflare</a><span> and </span><a href="https://console.upyun.com/register/?invite=H1xhvqTVV" target=_blank>又拍云</a></p></div></section><script src=//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-83215806-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script data-ad-client=ca-pub-4220670081232153 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></body></html>